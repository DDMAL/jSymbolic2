package jsymbolic2.processing;

import java.io.File;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.LinkedList;
import java.util.List;
import javax.sound.midi.*;
import mckay.utilities.staticlibraries.StringMethods;
import mckay.utilities.staticlibraries.MathAndStatsMethods;
import jsymbolic2.featureutils.CollectedNoteInfo;
import jsymbolic2.featureutils.NoteInfo;

/**
 * A class for preparing reports on the contents of a MIDI or MEI file (MEI files are converted to MIDI as
 * part of the processing objects of this class perform), or on groups of such files. Objects of this class
 * are instantiated with a reference to a single input MIDI or MEI file, which is then parsed by the
 * constructor. Reports about the MIDI file (or MEI file) and its contents may then be generated by calling
 * the object's various methods. Intraconsistency and interconsistency reports can also be generated about one
 * or more files via the static prepareConsistencyReports method.
 *
 * @author Cory McKay
 */
public class MIDIReporter
{
	/* PRIVATE FIELDS ***************************************************************************************/

	
	/**
	 * The MIDI or MEI file that is to be reported on.
	 */
	private final File parsed_file;
	
	/**
	 * General information about the parsed_file that is to be reported on. Set to null if parsed_file refers
	 * to an MEI file rather than a MIDI file.
	 */
	private MidiFileFormat midi_file_format;
	
	/**
	 * The MIDI sequence parsed from the parsed_file that is to be reported on.
	 */
	private Sequence sequence;

	/**
	 * The MIDI tracks parsed from the MIDI sequence that is to be reported on.
	 */
	private final Track[] tracks;

	/**
	 * The number of ticks per (quarter note) beat for the entire sequence
	 */
	private final int ppqn_ticks_per_beat;
	
	/**
	 * A matrix for sequence whose first index indicates MIDI track (this index matches the index of the array
	 * returned by Sequence.getTracks()) and whose second index indicates MIDI channel. Each entry is set to
	 * true if and only if at least one MIDI channel message occurs on the specified MIDI channel in the
	 * specified MIDI track.
	 */	
	private boolean[][] active_channels_per_track;
	
	/**
	 * An array for sequence whose entries indicate the number of different MIDI channels that contain at
	 * least one MIDI channel message are found on the MIDI track corresponding to the array index (this index
	 * matches the index of the array returned by Sequence.getTracks()).
	 */
	private int[] number_active_channels_per_track;
	
	/**
	 * The number of MIDI tracks in sequence that contain at least one channel message.
	 */
	private int number_of_tracks_with_channel_messages;
	
	
	/* CONSTRUCTOR ******************************************************************************************/


	/**
	 * Parse the specified MIDI or MEI file in preparation for being able to prepare reports based on the
	 * file. Note that only MIDI files using PPQ time encoding may be used (SMPTE time encoding is not
	 * accepted).
	 *
	 * @param	file_to_parse	A MIDI or MEI file to parse and report on. MEI files are converted to MIDI
	 *							as part of the parsing process.
	 * @throws	Exception		An informative exception is thrown if a problem is encountered during parsing.
	 *							This will occur if file_to_parse does not point to a valid MIDI or MEI file. 
	 *							It will also occur if a MIDI files uses SMPTE time encoding rather than PPQ
	 *							time encoding, or if the MIDI sequence is too long to process.
	 */
	public MIDIReporter(File file_to_parse)
		throws Exception
	{
		// Store and parse the file_to_parse
		parsed_file = file_to_parse;
		sequence = null;
		midi_file_format = null;
		try 
		{
			sequence = MidiSystem.getSequence(file_to_parse);
			midi_file_format = MidiSystem.getMidiFileFormat(file_to_parse);
		}
		catch (InvalidMidiDataException e)
		{
			if (SymbolicMusicFileUtilities.isValidMeiFile(file_to_parse))
				sequence = SymbolicMusicFileUtilities.getMeiSequenceFromMeiFile(file_to_parse, new LinkedList<>()).getSequence();
			else throw new Exception("The specified file, " + file_to_parse + ", is not a valid readable MIDI or MEI file.");
		}
		catch (IOException e)
		{
			throw new Exception("The specified path, " + file_to_parse + ", does not refer to a valid readable MIDI or MEI file.");
		}
		
		// Parse the MIDI sequence into MIDI tracks
		tracks = sequence.getTracks();
		if (sequence.getDivisionType() != Sequence.PPQ)
			throw new Exception("The MIDI sequence uses SMPTE time encoding. Only PPQ time encoding is accepted by this software.");
		if (((double) sequence.getTickLength()) > ((double) Integer.MAX_VALUE) - 1.0)
			throw new Exception("The MIDI sequence could not be processed because it is too long.");
		
		// Note the number of ticks per (quarter note) beat
		ppqn_ticks_per_beat = sequence.getResolution();
		
		// Note which and how many channels are active on each track, by filling out active_channels_per_track
		// and number_active_channels_per_track
		active_channels_per_track = new boolean[tracks.length][16];
		number_active_channels_per_track = new int[tracks.length];
		for (int tr = 0; tr < active_channels_per_track.length; tr++)
		{
			number_active_channels_per_track[tr] = 0;
			for (int ch = 0; ch < active_channels_per_track[tr].length; ch++)
				active_channels_per_track[tr][ch] = false;
		}
		for (int tr = 0; tr < tracks.length; tr++)
		{
			for (int ev = 0; ev < tracks[tr].size(); ev++)
			{
				MidiMessage message = tracks[tr].get(ev).getMessage();
				if (message instanceof ShortMessage)
				{
					int channel = ((ShortMessage) message).getChannel();
					active_channels_per_track[tr][channel] = true;
				}
			}
		}
		for (int tr = 0; tr < tracks.length; tr++)
			for (int ch = 0; ch < active_channels_per_track[tr].length; ch++)
				if (active_channels_per_track[tr][ch])
					number_active_channels_per_track[tr]++;
		number_of_tracks_with_channel_messages = 0;
		for (int tr = 0; tr < tracks.length; tr++)
			if (number_active_channels_per_track[tr] != 0)
				number_of_tracks_with_channel_messages++;
	}

	
	/* PUBLIC STATIC METHODS ********************************************************************************/

	
	/**
	 * Returns a formatted report on first the intaconsistency and then the interconsistency of
	 * files_to_check. Intraconsistency looks at whether each given file has more than one value for a range
	 * of quantities (e.g. more than one tempo, or more than one meter). Interconsistency looks at whether all
	 * the files share the same value or values for each of the quantities (e.g. all files have the same
	 * tempo, or the same set of tempos).
	 *
	 * @param files_to_check			A set of MIDI or MEI file to report on. MEI files are converted to 
	 *									MIDI as part of the parsing process.
	 * @param check_files_individually	Whether or not to report on intraconsistency.
	 * @param check_across_files		Whether or not to report on interconsistency.
	 * @param verbose					Whether to include in the report the actual values found (true), or 
	 *									only whether they are consistent or vary (false).
	 * @return							The formatted report.
	 * @throws Exception				An informative exception is thrown if a problem is encountered during
	 *									parsing. This will occur if a file in files_to_check does not point to
	 *									a valid MIDI or MEI file. It will also occur if a MIDI files uses 
	 *									SMPTE time encoding rather than PPQ	time encoding, or if the MIDI
	 *									sequence is too long to process.
	 */
	public static String prepareConsistencyReports( File[] files_to_check,
	                                                boolean check_files_individually,
	                                                boolean check_across_files,
	                                                boolean verbose )
		throws Exception
	{
		// The overall report to generate
		StringBuilder report = new StringBuilder();
		
		// Parse each symbolic music file, checking that it is valid. Throw an exception if even one of them
		// is not a valid MIDI or MEI file, or if a MID file uses SMPTE rather that PPQ timing.
		MIDIReporter[] reporters = new MIDIReporter[files_to_check.length];
		for (int i = 0; i < files_to_check.length; i++)
			reporters[i] = new MIDIReporter(files_to_check[i]);
				
		// The unique values found in each file for each relevant type of MIDI message. Duplicate message
		// values are removed (e.g. if multiple time signature message indicating time signature of 3/4 occur
		// for a given file, 3/4 will still only be included once for that particular file). The first index
		// indicates the file, and the second corresponds to the unique message. Values of null for a given
		// file inidcate that there are no messages of the given type for that file.
		String[][] unique_voices_found = new String[files_to_check.length][1];
		String[][] unique_tempos_found = new String[files_to_check.length][];
		String[][] unique_time_signatures_found = new String[files_to_check.length][];
		String[][] unique_key_signatures_found = new String[files_to_check.length][];
		String[][] unique_general_midi_patches_found = new String[files_to_check.length][];
		String[][] is_channel_10_used = new String[files_to_check.length][1];
		String[][] unique_velocities_found = new String[files_to_check.length][];
		String[][] unique_channel_volumes_found = new String[files_to_check.length][];
		String[][] unique_pitch_bend_values_found = new String[files_to_check.length][];
		String[][] unique_median_rhythmic_offsets_found = new String[files_to_check.length][1];
		String[][] unique_rhythmic_offsets_stdev_found = new String[files_to_check.length][1];
		String[][] channels_duplicated_on_multiple_tracks = new String[files_to_check.length][];
		String[][] unique_multiplexed_track_channels_found = new String[files_to_check.length][];
		String[][] unique_mid_file_types_found = new String[files_to_check.length][1];
		
		// Go through each file one-by-one, noting all the relevant MIDI messages and their associated values
		for (int file = 0; file < files_to_check.length; file++)
		{
			// The MIDI tracks in this file
			Track[] tracks = reporters[file].getMidiTracks();
		
			// Note the General MIDI patches referred to by program change messages in each track and channel,
			// with repetition (at first, at least). Also note the total number of MIDI Note On messages
			// (to help detect program change multiplexing on individual channels).
			LinkedList<String>[][] patches_per_channel_per_track = new LinkedList[tracks.length][16];
			long[][] note_on_count = new long[tracks.length][16];
			for (int track = 0; track < patches_per_channel_per_track.length; track++)
				for (int chan = 0; chan < patches_per_channel_per_track[track].length; chan++)
				{
					patches_per_channel_per_track[track][chan] = new LinkedList<>();
					note_on_count[track][chan] = 0;
				}
			
			// Prepare lists to hold the values for each relevant type of MIDI message found in this file
			LinkedList<String> tempo_values = new LinkedList<>();
			LinkedList<String> time_signature_values = new LinkedList<>();
			LinkedList<String> key_signature_values = new LinkedList<>();
			LinkedList<String> general_midi_patch_values = new LinkedList<>();
			LinkedList<String> channel_volume_values = new LinkedList<>();
			LinkedList<String> velocity_values = new LinkedList<>();
			LinkedList<String> pitch_bend_values = new LinkedList<>();
			LinkedList<String> multiplexed_track_channels = new LinkedList<>();
			
			// Go through the MIDI tracks one by one
			for (int tr = 0; tr < tracks.length; tr++)
			{	
				// Go through each MIDI event in this track
				for (int ev = 0; ev < tracks[tr].size(); ev++)
				{
					// The MIDI message associated with this MIDI event
					MidiMessage message = tracks[tr].get(ev).getMessage();
					
					// If this MIDI message is a MetaMessage
					if (message instanceof MetaMessage)
					{
						// The data bytes of this MetaMessage
						byte[] data = ((MetaMessage) message).getData();

						// If this is a tempo meta-message, then note it
						if (((MetaMessage) message).getType() == 0x51)
						{
							// Find tempo in microseconds per beat
							int ms_tempo = ((data[0] & 0xFF) << 16) | ((data[1] & 0xFF) << 8) | (data[2] & 0xFF);

							// Convert to beats per minute
							float ms_tempo_float = (float) ms_tempo;
							if (ms_tempo_float <= 0) ms_tempo_float = 0.1f;
							int tempo_bpm = (int) Math.round(60000000.0f / ms_tempo_float);

							// Note the tempo
							tempo_values.add((new Integer(tempo_bpm)).toString());
						}
						
						// If this is a time signature meta-message, then note it
						if (((MetaMessage) message).getType() == 0x58)
						{
							// The time signature numerator and denominator
							int time_signature_numerator = (int) (data[0] & 0xFF);
							int time_signature_denominator = (int) (1 << (data[1] & 0xFF));

							// Note the time signature
							time_signature_values.add(time_signature_numerator + "/" + time_signature_denominator);
						}
						
						// If this is a key signature meta-message, then note it
						if (((MetaMessage) message).getType() == 0x59)
						{
							// Interpret the key signature as major or minor
							String key_signture_info;
							if (data[1] == 0) key_signture_info = "Major with ";
							else key_signture_info = "Minor with ";

							// Interpret the key signature in terms of number of accidentals
							int number_accidentals = data[0];
							if (number_accidentals == 0)
								key_signture_info += (number_accidentals + " accidentals");
							else if (number_accidentals < 0)
								key_signture_info += (-1 * number_accidentals + " flats");
							else 
								key_signture_info += (number_accidentals + " sharps");

							// Note the key signature
							key_signature_values.add(key_signture_info);
						}
					}
					
					// If this is a ShortMessage
					if (message instanceof ShortMessage)
					{
						// This ShortMessage
						ShortMessage short_message = (ShortMessage) message;

						// This MIDI channel
						int channel = short_message.getChannel();

						// If this is a MIDI Program Change message
						if (short_message.getCommand() == 0xc0)
						{
							// The General MIDI patch number for this program change message
							int patch_number = short_message.getData1() + 1;

							// Note the General MIDI patch
							general_midi_patch_values.add((new Integer(patch_number)).toString());
							
							// Note the patch in this particular track and channel
							patches_per_channel_per_track[tr][channel].add((new Integer(patch_number)).toString());
						}

						// If this is a MIDI Channel Volume message
						if (short_message.getCommand() == 0xb0 && short_message.getData1() == 7)
						{
							// The channel volume
							long channel_volume = short_message.getData2();

							// Note the channel volume
							channel_volume_values.add((new Long(channel_volume)).toString());
						}
						
						// If this is a non-terminal (i.e. has a non-zero velocity) MIDI Note On message
						if (short_message.getCommand() == 0x90) // note on
						{
							if (short_message.getData2() != 0) // not velocity 0
							{
								// The velocity of this MIDI Note On
								int velocity = short_message.getData2();

								// Note the General MIDI patch
								velocity_values.add((new Integer(velocity)).toString());
								
								// Count this note
								note_on_count[tr][channel]++;
							}
						}

						// If this ShortMessage is a MIDI Pitch Bend message
						else if (short_message.getCommand() == 0xe0)
						{
							// The (second byte) value of the pitch bend (the less significant
							// first byte is ignored)
							int pitch_bend_value = short_message.getData2();

							// Note the General MIDI patch
							pitch_bend_values.add((new Integer(pitch_bend_value)).toString());
						}						
					}					
				}
			}

			// Calculate and store the total number of voices found in the piece. Each channel on each track
			// that contains at least one MIDI Note On is considered a separate voice. Also counts multiple
			// voices found on a single track and channel (via MIDI Program Change multiplexing with different
			// MIDI patches). If no General MIDI patch is specified for a given track and channel that 
			// contains Note Ons, then that track and channel is counted as a single voice. The same channel
			// used on multiple different tracks will be counted a multiple different voices. Also keep track
			// separately of which track channels are multiplexed
			long total_separate_voices_count = 0;
			for (int track = 0; track < patches_per_channel_per_track.length; track++)
				for (int chan = 0; chan < patches_per_channel_per_track[track].length; chan++)
				{
					if (note_on_count[track][chan] != 0)
					{
						// In case notes occur, but with the MIDI patch left unspecified
						int multiplexed_voices_on_this_track_channel = 1; 
					
						// Find the number of unique General MIDI patches on this track an dchannel
						String[] patches_this_channel_per_track_doubles_removed = StringMethods.getUniqueStrings(patches_per_channel_per_track[track][chan].toArray(new String[patches_per_channel_per_track[track][chan].size()]));
						if ( patches_this_channel_per_track_doubles_removed != null &&
							 patches_this_channel_per_track_doubles_removed.length != 0 )
						{
							multiplexed_voices_on_this_track_channel = patches_this_channel_per_track_doubles_removed.length;
							if (multiplexed_voices_on_this_track_channel > 1)
								multiplexed_track_channels.add("Track " + track + " Chan " + chan);
						}
						total_separate_voices_count += multiplexed_voices_on_this_track_channel;
					}
				}
			unique_voices_found[file][0] = (new Long(total_separate_voices_count)).toString();
			if (!multiplexed_track_channels.isEmpty())
				unique_multiplexed_track_channels_found[file] = multiplexed_track_channels.toArray(new String[multiplexed_track_channels.size()]);
			else unique_multiplexed_track_channels_found[file] = null;
			
			// Report on whether there are any MIDI Channel 10 (unpitched) notes played
			is_channel_10_used[file][0] = "Not present in file";
			for (boolean[] channels_on_this_track : reporters[file].getActiveChannelsPerTrack())
				if (channels_on_this_track[10-1])
					is_channel_10_used[file][0] = "Present";
			
			// Do rhythmic value offset processing
			double[] rhythmic_value_offsets = getRhytmicValueOffsets(reporters[file].getMidiSequence());
			double median_rhthymic_value_offset = MathAndStatsMethods.getMedianValue(rhythmic_value_offsets);
			double rhthymic_value_offset_stdev = MathAndStatsMethods.getStandardDeviation(rhythmic_value_offsets);
			DecimalFormat formatter = new java.text.DecimalFormat("#.###");
			unique_median_rhythmic_offsets_found[file][0] = formatter.format(median_rhthymic_value_offset);
			unique_rhythmic_offsets_stdev_found[file][0] = formatter.format(rhthymic_value_offset_stdev);
			
			// Report on whether any MIDI tracks include MIDI channel messages on a MIDI channel that also
			// has MIDI channel messages on the same channel on another MIDI track
			LinkedList<String> chans_duplicated_on_multiple_tracks = new LinkedList<>();
			LinkedList<Integer>[] tracks_using_each_channel = new LinkedList[16];
			for (int ch = 0; ch < tracks_using_each_channel.length; ch++)
				tracks_using_each_channel[ch] = new LinkedList<>();
			boolean[][] active_channels_per_track = reporters[file].getActiveChannelsPerTrack();
			for (int tr = 0; tr < active_channels_per_track.length; tr++)
				for (int ch = 0; ch < active_channels_per_track[tr].length; ch++)
					if (active_channels_per_track[tr][ch])
						tracks_using_each_channel[ch].add(tr);
			for (int ch = 0; ch < tracks_using_each_channel.length; ch++)
				if (tracks_using_each_channel[ch].size() > 1)
					chans_duplicated_on_multiple_tracks.add((new Integer(ch)).toString());
			if (!chans_duplicated_on_multiple_tracks.isEmpty())
				channels_duplicated_on_multiple_tracks[file] = chans_duplicated_on_multiple_tracks.toArray(new String[chans_duplicated_on_multiple_tracks.size()]);
			else channels_duplicated_on_multiple_tracks[file] = null;
					
			// Store the MIDI file type of this file
			MidiFileFormat this_midi_file_format = reporters[file].getMidiFileFormat();
			if (this_midi_file_format == null)
				unique_mid_file_types_found[file][0] = "MEI (translated into MIDI for this report)";
			else
				unique_mid_file_types_found[file][0] = Integer.toString(this_midi_file_format.getType());
			
			// Store the MIDI message values found for this file, removing duplicates
			unique_tempos_found[file] = StringMethods.getUniqueStrings(tempo_values.toArray(new String[tempo_values.size()]));
			unique_time_signatures_found[file] = StringMethods.getUniqueStrings(time_signature_values.toArray(new String[time_signature_values.size()]));
			unique_key_signatures_found[file] = StringMethods.getUniqueStrings(key_signature_values.toArray(new String[key_signature_values.size()]));
			unique_general_midi_patches_found[file] = StringMethods.getUniqueStrings(general_midi_patch_values.toArray(new String[key_signature_values.size()]));
			unique_channel_volumes_found[file] = StringMethods.getUniqueStrings(channel_volume_values.toArray(new String[key_signature_values.size()]));
			unique_velocities_found[file] = StringMethods.getUniqueStrings(velocity_values.toArray(new String[key_signature_values.size()]));
			unique_pitch_bend_values_found[file] = StringMethods.getUniqueStrings(pitch_bend_values.toArray(new String[key_signature_values.size()]));
		}

		// Prepare intraconsistency reports for individual files
		if (check_files_individually)
		{
			// Lists of inconsistences found for each file. The file is denoted by the array's index. Used
			// to generate the summary report
			LinkedList<String>[] inconsistencies_found = new LinkedList[files_to_check.length];
			for (int i = 0; i < inconsistencies_found.length; i++)
				inconsistencies_found[i] = new LinkedList<>();

			// Prepare a formatted intraconsistency report for each individual file
			for (int file = 0; file < files_to_check.length; file++)
			{
				report.append("\n============ INTRACONSISTENCY REPORT FOR FILE " + (file+1) + "/" + files_to_check.length + " ============\n\n");
				report.append("\tFILE NAME: " + files_to_check[file].getAbsolutePath() + "\n");
				report.append("\tNUMBER OF VOICES: " + getIntraConsistencyReport(unique_voices_found[file], verbose, "Number Of Voices", inconsistencies_found[file]) + "\n");
				report.append("\tTEMPO: " + getIntraConsistencyReport(unique_tempos_found[file], verbose, "Tempo", inconsistencies_found[file]) + "\n");
				report.append("\tTIME SIGNATURE: " + getIntraConsistencyReport(unique_time_signatures_found[file], verbose, "Time Signature", inconsistencies_found[file]) + "\n");
				report.append("\tKEY SIGNATURE: " + getIntraConsistencyReport(unique_key_signatures_found[file], verbose, "Key Signature", inconsistencies_found[file]) + "\n");
				report.append("\tGENERAL MIDI PATCHES: " + getIntraConsistencyReport(unique_general_midi_patches_found[file], verbose, "General MIDI Patches", inconsistencies_found[file]) + "\n");
				report.append("\tUNPITCHED CHANNEL 10 NOTES: " + getIntraConsistencyReport(is_channel_10_used[file], verbose, "Unpitched Channel 10 Notes", inconsistencies_found[file]) + "\n");
				report.append("\tNOTE VELOCITIES: " + getIntraConsistencyReport(unique_velocities_found[file], verbose, "Note Velocities", inconsistencies_found[file]) + "\n");
				report.append("\tCHANNEL VOLUMES: " + getIntraConsistencyReport(unique_channel_volumes_found[file], verbose, "Channel Volumes", inconsistencies_found[file]) + "\n");
				report.append("\tPITCH BEND VALUES: " + getIntraConsistencyReport(unique_pitch_bend_values_found[file], verbose, "Pitch Bend Values", inconsistencies_found[file]) + "\n");
				report.append("\tMEDIAN RHYTHMIC OFFSET: " + getIntraConsistencyReport(unique_median_rhythmic_offsets_found[file], verbose, "Median Rhythmic Offset", inconsistencies_found[file]) + "\n");
				report.append("\tRHYTHMIC OFFSET STDEV: " + getIntraConsistencyReport(unique_rhythmic_offsets_stdev_found[file], verbose, "Rhythmic Offset STDEV", inconsistencies_found[file]) + "\n");
				report.append("\tDUPLICATED MIDI CHANNELS: " + getIntraConsistencyReport(channels_duplicated_on_multiple_tracks[file], verbose, "Duplicated MIDI Channels", inconsistencies_found[file]) + "\n");
				report.append("\tMULTIPLEXED MIDI TRACKS AND CHANNELS: " + getIntraConsistencyReport(unique_multiplexed_track_channels_found[file], verbose, "Multiplexed MIDI Tracks and Channels", inconsistencies_found[file]) + "\n");
				report.append("\tMIDI FILE TYPE: " + getIntraConsistencyReport(unique_mid_file_types_found[file], verbose, "MIDI File Type", inconsistencies_found[file]) + "\n");
			}
			report.append("\n");

			// Prepare summary intraconsistency report
			if (files_to_check.length > 1)
			{
				report.append("************ SUMMARY FILE INTRACONSISTENCY REPORT ************\n\n");

				int number_of_files_with_internal_inconsistencies = 0;
				for (int file = 0; file < files_to_check.length; file++)
					if (!inconsistencies_found[file].isEmpty())
						number_of_files_with_internal_inconsistencies++;
				
				report.append("\tNUMBER OF FILES WITH INTERNAL INCONSISTENCES: " + number_of_files_with_internal_inconsistencies + "\n");
				
				int processed_so_far = 0;
				for (int file = 0; file < files_to_check.length; file++)
				{
					if (!inconsistencies_found[file].isEmpty())
					{
						processed_so_far++;
						report.append( "\n\tInternally inconsistent file " + processed_so_far + "/" + 
						               number_of_files_with_internal_inconsistencies + ": " + 
						               files_to_check[file].getAbsolutePath() + "\n" );
						for (int inc = 0; inc < inconsistencies_found[file].size(); inc++)
							report.append( "\t\tInconsistency " + (inc+1) + "/" + 
							               inconsistencies_found[file].size() + ": " +
							               inconsistencies_found[file].get(inc) + "\n" );
					}
				}
			}
		}
		
		// Prepare an interconsistency reports across all files
		if (check_across_files && files_to_check.length > 1)
		{
			report.append("\n************ SUMMARY FILE INTERCONSISTENCY REPORT ************\n\n");
			report.append("\tNUMBER OF VOICES: " + getInterConsistencyReport(unique_voices_found, files_to_check, verbose) + "\n");
			report.append("\tTEMPO: " + getInterConsistencyReport(unique_tempos_found, files_to_check, verbose) + "\n");
			report.append("\tTIME SIGNATURE: " + getInterConsistencyReport(unique_time_signatures_found, files_to_check, verbose) + "\n");
			report.append("\tKEY SIGNATURE: " + getInterConsistencyReport(unique_key_signatures_found, files_to_check, verbose) + "\n");
			report.append("\tGENERAL MIDI PATCHES: " + getInterConsistencyReport(unique_general_midi_patches_found, files_to_check, verbose) + "\n");
			report.append("\tUNPITCHED CHANNEL 10 NOTES: " + getInterConsistencyReport(is_channel_10_used, files_to_check, verbose) + "\n");
			report.append("\tNOTE VELOCITIES: " + getInterConsistencyReport(unique_velocities_found, files_to_check, verbose) + "\n");
			report.append("\tCHANNEL VOLUMES: " + getInterConsistencyReport(unique_channel_volumes_found, files_to_check, verbose) + "\n");
			report.append("\tPITCH BEND VALUES: " + getInterConsistencyReport(unique_pitch_bend_values_found, files_to_check, verbose) + "\n");
			report.append("\tMEDIAN RHYTHMIC OFFSET: " + getInterConsistencyReport(unique_median_rhythmic_offsets_found, files_to_check, verbose) + "\n");
			report.append("\tRHYTHMIC OFFSET STDEV: " + getInterConsistencyReport(unique_rhythmic_offsets_stdev_found, files_to_check, verbose) + "\n");
			report.append("\tDUPLICATED MIDI CHANNELS: " + getInterConsistencyReport(channels_duplicated_on_multiple_tracks, files_to_check, verbose) + "\n");
			report.append("\tMULTIPLEXED MIDI TRACKS AND CHANNELS: " + getInterConsistencyReport(unique_multiplexed_track_channels_found, files_to_check, verbose) + "\n");
			report.append("\tMIDI FILE TYPE: " + getInterConsistencyReport(unique_mid_file_types_found, files_to_check, verbose) + "\n");
			report.append("\n");
		}
		
		// Return the report
		return report.toString();
	}
	
	
	/* PUBLIC METHODS ***************************************************************************************/


	/**
	 * Return the MIDIFileFormat that this object has parsed and stored.
	 * 
	 * @return	General information about the parsed_file that is to be reported on. Set to null if the
	 *			parsed file was an MEI (which has been parsed via internal conversion to MIDI).
	 */	
	public MidiFileFormat getMidiFileFormat()
	{
		return midi_file_format;
	}
	
	
	/**
	 * Return the MIDI sequence that this object has parsed and stored.
	 * 
	 * @return	The MIDI sequence that this object has parsed and stored.
	 */
	public Sequence getMidiSequence()
	{
		return sequence;
	}

	
	/**
	 * Return the MIDI tracks that this object has parsed and stored.
	 * 
	 * @return	The MIDI tracks that this object has parsed and stored.
	 */
	public final Track[] getMidiTracks()
	{
		return tracks;
	}
	
	
	/**
	 * Return, for each MIDI track that this object has parsed and stored, information on which MIDI channels 
	 * 
	 * @return	A matrix whose first index indicates MIDI track (this index matches the index of the array
	 *			returned by Sequence.getTracks()) and whose second index indicates MIDI channel. Each entry is 
	 *			set to true if and only if at least one MIDI channel message occurs on the specified MIDI 
	 *			channel in the specified MIDI track.
	 */	
	public boolean[][] getActiveChannelsPerTrack()
	{
		return active_channels_per_track;
	}
	
	
	/**
	 * Return a formatted report listing overall information about the parsed MIDI or MEI file and the MIDI
	 * sequence in contains. This includes: overall information about the file, its size and its MIDI type (0,
	 * 1 or 2); textural metadata stored in the file (if available); a breakdown of the MIDI tracks and the
	 * MIDI channels used; and rhythm and timing overview information.
	 *
	 * @return				The formatted report.
	 * @throws	IOException	Throws an exception if a problem occurs accessing the file that was parsed.
	 */
	public String prepareHeaderReport()
		throws IOException
	{
		// The overall report to generate
		StringBuilder report = new StringBuilder();
		
		// Report file data
		report.append("\nFILE DATA:\n");
		report.append("\tFile name: " + parsed_file.getName() + "\n");
		report.append("\tFile path: " + parsed_file.getCanonicalPath() + "\n");
		report.append("\tFile size: " + parsed_file.length() + " bytes\n");
		if (midi_file_format != null)
			report.append("\tMIDI file type: " + midi_file_format.getType() + "\n");
		else report.append("\tMIDI file type: " + "MEI (translated into MIDI for this report)" + "\n");
		
		// Report MIDI metadata (if any is available)
		if ( midi_file_format != null &&
		     midi_file_format.getProperty("title") != null && 
		     midi_file_format.getProperty("author") != null &&
		     midi_file_format.getProperty("copyright") != null && 
		     midi_file_format.getProperty("date") != null &&
		     midi_file_format.getProperty("comment") != null ) 
		{
			report.append("\nFILE METADATA:\n");
			report.append("\tTitle: " + midi_file_format.getProperty("title")+ "\n");
			report.append("\tAuthor: " + midi_file_format.getProperty("author") + "\n");
			report.append("\tCopyright: " + midi_file_format.getProperty("copyright") + "\n");
			report.append("\tDate: " + midi_file_format.getProperty("date") + "\n");
			report.append("\tComment: " + midi_file_format.getProperty("comment") + "\n");
		}
		
		// Report header for track and channel overview data
		report.append("\nMIDI TRACK AND CHANNEL OVERVIEW DATA:\n");
		
		// Report the number of channel messages, combined across all MIDI tracks
		int total_number_active_channels = 0;
		for (int tr = 0; tr < number_active_channels_per_track.length; tr++)
			total_number_active_channels += number_active_channels_per_track[tr];
		report.append("\tNumber of MIDI channels containing MIDI channel messages (combined across all tracks): " + 
			total_number_active_channels + "\n");

		// Report the number of MIDI track overall
		report.append("\tNumber of MIDI tracks (with or without channel messages): " + tracks.length + "\n");

		// Report the number of tracks containing MIDI channel messages. Then, for each track, indicate how
		// many and which MIDI channels contain MIDI messages
		report.append("\tNumber of MIDI tracks containing MIDI channel messages: " +
			number_of_tracks_with_channel_messages + "\n");
		for (int tr = 0; tr < tracks.length; tr++)
		{
			report.append("\t\tNumber of channels with channel messages on track " + (tr + 1) + ": " + 
				number_active_channels_per_track[tr]);
			if (number_active_channels_per_track[tr] != 0)
			{
				report.append(" (channel(s) ");
				boolean found_one = false;
				for (int ch = 0; ch < active_channels_per_track[tr].length; ch++)
					if (active_channels_per_track[tr][ch])
					{
						if (found_one)
							report.append(", ");
						report.append(ch + 1);
						found_one = true;
					}
				if (found_one) report.append(")");
			}
			report.append("\n");
		}
		
		// Report on rhythm and timing
		report.append("\nRHYTHM AND TIMING INFORMATION:\n");
		long total_number_beats = Math.round((double) sequence.getTickLength() / (double) ppqn_ticks_per_beat);
		report.append("\tDuration in beats: " + total_number_beats + " (quarter note) beats\n");
		String duration_in_seconds = (new java.text.DecimalFormat("#.##")).format(((float) sequence.getMicrosecondLength()) / 1000000.0);
		report.append("\tDuration in time: " + duration_in_seconds + " seconds\n");
		report.append("\tDuration in ticks: " + sequence.getTickLength() + " MIDI ticks \n");
		report.append("\tPPQ timing resolution: " + sequence.getResolution()+ " MIDI ticks per (quarter note) beat\n");

		// Return the report
		return report.toString();	
	}

	
	/**
	 * Return a formatted report listing all MIDI meta-messages of the specified types that occur in the
	 * piece, segregated by type of MIDI message and by MIDI track. Only those MIDI tracks that contain a
	 * given type of meta-message at least once are listed in each of these reports. Only those types of MIDI
	 * meta-messages that are present at least once will be mentioned in the report.
	 *
	 * @param report_tempo						Whether or not to report tempo MIDI meta-messages.
	 * @param report_time_signature				Whether or not to report time signature MIDI meta-messages.
	 * @param report_key_signature				Whether or not to report key signature MIDI meta-messages.
	 * @param report_track_and_instrument_names	Whether or not to report track and instrument name  MIDI
	 *											meta-messages.
	 * @param report_miscellaneous_text			Whether or not to report miscellaneous text MIDI
	 *											meta-messages.
	 * @param report_lyrics						Whether or not to report lyrics MIDI meta-messages.
	 * @return									A formatted report of all the requested meta-messages that are
	 *											present. Includes the (quarter note) beat and MIDI tick for
	 *											each such MIDI meta-message. Both beats and ticks are
	 *											incremented by one in order to report as if the music starts
	 *											on beat 1 and tick 1, rather than beat 0 and tick 0.
	 */
	public String prepareMetaMessageReport( boolean report_tempo,
	                                        boolean report_time_signature,
	                                        boolean report_key_signature,
	                                        boolean report_track_and_instrument_names,
	                                        boolean report_miscellaneous_text,
	                                        boolean report_lyrics )
	{
		// The report of all MIDI tempo meta-messages found
		StringBuilder tempo_report = new StringBuilder();
				
		// The report of all MIDI time signature meta-messages found
		StringBuilder time_signature_report = new StringBuilder();
				
		// The report of all MIDI key signature meta-messages found
		StringBuilder key_signature_report = new StringBuilder();
				
		// The report of all MIDI track name and instrument name meta-messages found
		StringBuilder track_and_instrument_names_report = new StringBuilder();
				
		// The report of all MIDI text meta-messages found
		StringBuilder text_report = new StringBuilder();
				
		// The report of all MIDI lyrics meta-messages found
		StringBuilder lyrics_report = new StringBuilder();
				
		// Go through the MIDI tracks one by one
		for (int tr = 0; tr < tracks.length; tr++)
		{	
			// A report of MIDI tempo meta-messages for this MIDI track (will be generated regardless of
			// whether or not there are meta-messages of this type on this track, but will only be added to 
			// the final report if there are. Also prepare to note if a meta-message of this type was found on
			// this track, and to count the number of meta- messages of this type.
			StringBuilder temp_tempo_report = new StringBuilder();
			temp_tempo_report.append("\nTEMPO MESSAGES ON TRACK " + (tr + 1) + ":\n");
			boolean found_tempo = false;
			long tempo_count = 0;

			// A report of MIDI time signature meta-messages for this MIDI track (will be generated
			// regardless of whether or not there are meta-messages of this type on this track, but will
			// only be added to the final report if there are. Also prepare to note if a meta-message of this
			// type was found on this track, and to count the number of meta- messages of this type.
			StringBuilder temp_time_signature_report = new StringBuilder();
			temp_time_signature_report.append("\nTIME SIGNATURE MESSAGES ON TRACK " + (tr + 1) + ":\n");
			boolean found_time_signature = false;
			long time_signature_count = 0;

			// A report of MIDI key signature meta-messages for this MIDI track (will be generated
			// regardless of whether or not there are meta-messages of this type on this track, but will
			// only be added to the final report if there are. Also prepare to note if a meta-message of this
			// type was found on this track, and to count the number of meta- messages of this type.
			StringBuilder temp_key_signature_report = new StringBuilder();
			temp_key_signature_report.append("\nKEY SIGNATURE MESSAGES ON TRACK " + (tr + 1) + ":\n");
			boolean found_key_signature = false;
			long key_signature_count = 0;

			// A report of MIDI track and instrument name meta-messages for this MIDI track (will be generated
			// regardless of whether or not there are meta-messages of this type on this track, but will
			// only be added to the final report if there are. Also prepare to note if a meta-message of this
			// type was found on this track.
			StringBuilder temp_track_and_instrument_names_report = new StringBuilder("\nTRACK NAME AND INSTRUMENT NAME MESSAGES ON TRACK " + (tr + 1) + ":\n");
			boolean found_track_or_instrument_name = false;

			// A report of MIDI text meta-messages for this MIDI track (will be generated
			// regardless of whether or not there are meta-messages of this type on this track, but will
			// only be added to the final report if there are. Also prepare to note if a meta-message of this
			// type was found on this track, and to count the number of meta- messages of this type.
			StringBuilder temp_text_report = new StringBuilder();
			temp_text_report.append("\nTEXT MESSAGES ON TRACK " + (tr + 1) + ":\n");
			boolean found_text = false;
			long text_count = 0;

			// A report of MIDI lyrics meta-messages for this MIDI track (will be generated
			// regardless of whether or not there are meta-messages of this type on this track, but will
			// only be added to the final report if there are. Also prepare to note if a meta-message of this
			// type was found on this track, and to count the number of meta- messages of this type.
			StringBuilder temp_lyrics_report = new StringBuilder();
			temp_lyrics_report.append("\nLYRICS MESSAGES ON TRACK " + (tr + 1) + ":\n");
			boolean found_lyrics = false;
			long lyrics_count = 0;

			// Go through each MIDI event in this track
			for (int ev = 0; ev < tracks[tr].size(); ev++)
			{
				// The MIDI message associated with this MIDI event
				MidiMessage message = tracks[tr].get(ev).getMessage();
						
				// The tick that this MIDI event is starting on
				long event_tick = tracks[tr].get(ev).getTick();
				
				// If this MIDI message is a MetaMessage
				if (message instanceof MetaMessage)
				{
					// The data bytes of this MetaMessage
					byte[] data = ((MetaMessage) message).getData();

					// If this is a tempo meta-message, then report it
					if (((MetaMessage) message).getType() == 0x51)
					{
						// Increment the count
						tempo_count++;

						// Find tempo in microseconds per beat
						int ms_tempo = ((data[0] & 0xFF) << 16) | ((data[1] & 0xFF) << 8) | (data[2] & 0xFF);

						// Convert to beats per minute
						float ms_tempo_float = (float) ms_tempo;
						if (ms_tempo_float <= 0) ms_tempo_float = 0.1f;
						int tempo_bpm = (int) Math.round(60000000.0f / ms_tempo_float);
						
						// Report the tempo
						temp_tempo_report.append("\tTEMPO " + tempo_count + ": " + tempo_bpm + 
							" BPM, Beat: " + getBeatNumber(event_tick) + ", Tick " + (event_tick + 1) +
							", Track " + (tr + 1) + "\n");
						
						// Note that a tempo was found
						found_tempo = true;
					}						
				
					// If this is a time signature meta-message, then report it
					if (((MetaMessage) message).getType() == 0x58)
					{
						// Increment the count
						time_signature_count++;
						
						// The time signature numerator and denominator
						int time_signature_numerator = (int) (data[0] & 0xFF);
						int time_signature_denominator = (int) (1 << (data[1] & 0xFF));

						// Report the time signature
						temp_time_signature_report.append("\tTIME SIGNATURE " + time_signature_count + ": " +
							time_signature_numerator + "/" + time_signature_denominator + ", Beat: " + 
							getBeatNumber(event_tick) + ", Tick " + (event_tick + 1) + ", Track " + (tr + 1) +
							"\n");
						
						// Note that a time signature was found
						found_time_signature = true;
					}						
				
					// If this is a key signature meta-message, then report it
					if (((MetaMessage) message).getType() == 0x59)
					{
						// Increment the count
						key_signature_count++;
						
						// Interpret the key signature as major or minor
						String key_signture_info;
						if (data[1] == 0) key_signture_info = "Major with ";
						else key_signture_info = "Minor with ";
						
						// Interpret the key signature in terms of number of accidentals
						int number_accidentals = data[0];
						if (number_accidentals == 0)
							key_signture_info += (number_accidentals + " accidentals");
						else if (number_accidentals < 0)
							key_signture_info += (-1 * number_accidentals + " flats");
						else 
							key_signture_info += (number_accidentals + " sharps");
						
						// Report the key signature
						temp_key_signature_report.append("\tKEY SIGNATURE " + key_signature_count + ": " +
							key_signture_info + ", Beat: " + getBeatNumber(event_tick) + ", Tick " + 
							(event_tick + 1) + ", Track " + (tr + 1) + "\n");
						
						// Note that a key signature was found
						found_key_signature = true;
					}

					// If this is a track name or instrument name meta-message, then report it
					if ( ((MetaMessage) message).getType() == 0x03 || // Track name
					     ((MetaMessage) message).getType() == 0x04 ) // Instrument name
					{
						// Interpret the field
						if (((MetaMessage) message).getType() == 0x03)
							temp_track_and_instrument_names_report.append("\tTRACK");
						else if (((MetaMessage) message).getType() == 0x03)
							temp_track_and_instrument_names_report.append("\tINSTRUMENT");
							
						// Interpret the data
						StringBuilder this_report = new StringBuilder();
						for (int ch = 0; ch < data.length; ch++)
							this_report.append((char) (data[ch]));
						
						// Report the track name or instrument name
						temp_track_and_instrument_names_report.append(" NAME FOR TRACK " + (tr + 1) + ": \"" + 
							this_report.toString() + "\", Beat: " + getBeatNumber(event_tick) + ", Tick " + 
							(event_tick + 1) + ", Track " + (tr + 1) + "\n");
						
						// Note that a track name or instrument name was found
						found_track_or_instrument_name = true;
					}

					// If this is a text meta-message, then report it
					if ( ((MetaMessage) message).getType() == 0x01 )
					{
						// Interpret the data
						StringBuilder this_report = new StringBuilder();
						for (int ch = 0; ch < data.length; ch++)
						{
							char this_character = (char) data[ch];
							if (String.valueOf(this_character).matches(".")) // verify is not a new line char
								this_report.append(this_character);
							else this_report.append("\\n");
						}

						// Report the text
						temp_text_report.append("\tTEXT FOR TRACK " + (tr + 1) + ": \"" + 
							this_report.toString() + "\", Beat: " + getBeatNumber(event_tick) + ", Tick " + 
							(event_tick + 1) + ", Track " + (tr + 1) + "\n");
						
						// Note that a track name or instrument name was found
						found_text = true;
					}					
					
					// If this is a lyrics meta-message, then report it
					if ( ((MetaMessage) message).getType() == 0x05 )
					{
						// Interpret the data
						StringBuilder this_report = new StringBuilder();
						for (int ch = 0; ch < data.length; ch++)
						{
							char this_character = (char) data[ch];
							if (String.valueOf(this_character).matches(".")) // verify is not a new line char
								this_report.append(this_character);
							else this_report.append("\\n");
						}

						// Report the lyrics
						temp_lyrics_report.append("\tLYRICS FOR TRACK " + (tr + 1) + ": \"" + 
							this_report.toString() + "\", Beat: " + getBeatNumber(event_tick) + ", Tick " + 
							(event_tick + 1) + ", Track " + (tr + 1) + "\n");
						
						// Note that a lyrics message was found
						found_lyrics = true;
					}
				}
			}
			
			// Report only those meta-message types that occur at least once
			if (found_tempo)
				tempo_report.append(temp_tempo_report.toString());
			if (found_time_signature)
				time_signature_report.append(temp_time_signature_report.toString());
			if (found_key_signature)
				key_signature_report.append(temp_key_signature_report.toString());
			if (found_track_or_instrument_name)
				track_and_instrument_names_report.append(temp_track_and_instrument_names_report.toString());
			if (found_text)
				text_report.append(temp_text_report.toString());
			if (found_lyrics)
				lyrics_report.append(temp_lyrics_report.toString());
		}
			
		// Generate and return the combined report
		StringBuilder combined_report = new StringBuilder();
		if (report_tempo) combined_report.append(tempo_report);
		if (report_time_signature) combined_report.append(time_signature_report);
		if (report_key_signature) combined_report.append(key_signature_report);
		if (report_track_and_instrument_names) combined_report.append(track_and_instrument_names_report);
		if (report_miscellaneous_text) combined_report.append(text_report);
		if (report_lyrics) combined_report.append(lyrics_report);
		return combined_report.toString();	
	}
	
	
	/**
	 * Return a formatted report listing all MIDI Program Change messages (i.e. changes of instrumentation)
	 * that occur in the piece, segregated by MIDI track and MIDI channel. Also report whether or not the
	 * piece contains any non-pitched instruments (i.e. notes on MIDI channel 10).
	 *
	 * @return	A formatted report on whether there are any Channel 10 unpitched notes present in the piece,
	 *			followed by a separate formatted report of all MIDI Program Change messages. Includes the
	 *			(quarter note) beat and	MIDI tick for each such note's start and stop. Both beats and ticks
	 *			are incremented by one in order to report as if the music starts on beat 1 and tick 1, rather 
	 *			than beat 0 and tick 0. Patch numbers are also incremented by 1, such that reported General 
	 *			MIDI patch codes start at 1 rather than at 0.
	 */
	public String prepareProgramChangeAndUnpitchedInstrumentsReport()
	{
		// The report to generate
		StringBuilder report = new StringBuilder();
		
		// Report on whether there are any MIDI Channel 10 (unpitched) notes played
		boolean channel_10_used = false;
		for (boolean[] channels_on_this_track : active_channels_per_track)
			if (channels_on_this_track[10-1])
				channel_10_used = true;
		report.append("\nUNPITCHED NOTES ON MIDI CHANNEL 10:\n");
		if(channel_10_used) report.append("\tYES, there are MIDI Channel 10 unpitched notes present.\n");
		else report.append("\tNO, there are not any MIDI Channel 10 unpitched notes present.\n");
		
		// Go through the MIDI tracks one by one
		for (int tr = 0; tr < tracks.length; tr++)
		{	
			// Go through active MIDI channels in this MIDI track one by one
			for (int ch = 0; ch < active_channels_per_track[tr].length; ch ++)
			{
				// Only add to the report if there is at least one message on this channel in this track
				if (active_channels_per_track[tr][ch])
				{
					// Note that a new MIDI track and a new MIDI channel is starting
					report.append("\nPROGRAM CHANGE MESSAGES ON TRACK " + (tr + 1) + " AND CHANNEL " +
						(ch + 1) + ":\n");

					// The number of MIDI Program Change messages encountered on this track and channel
					long program_change_count = 0;

					// Go through each MIDI event in this track
					for (int ev = 0; ev < tracks[tr].size(); ev++)
					{
						// This MIDI event
						MidiEvent event = tracks[tr].get(ev);

						// The MIDI message associated with this MIDI event
						MidiMessage message = event.getMessage();

						// The tick that this event is starting on
						long event_tick = event.getTick();

						// If this is a ShortMessage (which Program Change messages are)
						if (message instanceof ShortMessage)
						{
							// This ShortMessage
							ShortMessage short_message = (ShortMessage) message;

							// This MIDI channel
							int channel = short_message.getChannel();

							// Only add to the report if there is at least one message on this channel in this
							// track
							if (short_message.getChannel() == ch)
							{
								// If this is a MIDI Program Change message
								if (short_message.getCommand() == 0xc0)
								{
									// Increment the count
									program_change_count++;
											
									// The General MIDI patch number for this program change message
									int patch_number = short_message.getData1();

									// Report the time signature
									report.append("\tPROGRAM CHANGE " + program_change_count + ": Patch " + 
										(patch_number + 1) + ", Beat: " + getBeatNumber(event_tick) + 
										", Tick " + (event_tick + 1) + ", Track " + (tr + 1) + ", Channel " +
										(channel + 1) + "\n");
								}
							}
						}
					}
				}
			}
		}

		// Return the report
		return report.toString();			
	}
	

	/**
	 * Return a formatted report listing all MIDI Channel Volume messages that occur in the piece, segregated
	 * by MIDI track and MIDI channel. IMPORTANT: only coarse channel volume (CC 7) messages are considered,
	 * not expression (CC 11) or fine channel volume (CC 39) messages are considered. Other types of
	 * controller messages are note reported.
	 * 
	 * @return	A formatted report of all MIDI Channel Volume messages. Includes the (quarter note) beat and
	 *			MIDI tick for each such note's start and stop. Both beats and ticks are incremented by one in
	 *			order to report as if the music starts on beat 1 and tick 1, rather than beat 0 and tick 0.
	 */	
	public String prepareControllerMessageReport()
	{
		// The report to generate
		StringBuilder report = new StringBuilder();
		
		// Go through the MIDI tracks one by one
		for (int tr = 0; tr < tracks.length; tr++)
		{	
			// Go through active MIDI channels in this MIDI track one by one
			for (int ch = 0; ch < active_channels_per_track[tr].length; ch ++)
			{
				// A report of MIDI channel volume messages for this MIDI track and channel (will be generated
				// regardless of whether or not there are, but will only be added to the final report if there
				// are. Also prepare to count the number of messages of this type.
				StringBuilder temp_channel_volume_report = new StringBuilder();
				temp_channel_volume_report.append("\nCHANNEL VOLUME MESSAGES ON TRACK " + (tr + 1) + 
					" AND CHANNEL " + (ch + 1) + ":\n");
				long channel_volume_count = 0;

				// Only add to the report if there is at least one message on this channel in this track
				if (active_channels_per_track[tr][ch])
				{
					// Go through each MIDI event in this track
					for (int ev = 0; ev < tracks[tr].size(); ev++)
					{
						// This MIDI event
						MidiEvent event = tracks[tr].get(ev);

						// The MIDI message associated with this MIDI event
						MidiMessage message = event.getMessage();

						// The tick that this event is starting on
						long event_tick = event.getTick();

						// If this is a ShortMessage (which Channel Volume messages are)
						if (message instanceof ShortMessage)
						{
							// This ShortMessage
							ShortMessage short_message = (ShortMessage) message;

							// This MIDI channel
							int channel = short_message.getChannel();

							// Only add to the report if there is at least one message on this channel in this
							// track
							if (short_message.getChannel() == ch)
							{
								// If this is a MIDI Channel Volume message
								if (short_message.getCommand() == 0xb0 && short_message.getData1() == 7)
								{
									// Increment the count
									channel_volume_count++;
											
									// The channel volume
									long channel_volume = short_message.getData2();

									// Report the channel volume
									temp_channel_volume_report.append("\tCHANNEL VOLUME " + 
										channel_volume_count + ": " + channel_volume + "/127, Beat: " + 
										getBeatNumber(event_tick) + ", Tick " + (event_tick + 1) + 
										", Track " + (tr + 1) + ", Channel " + (channel + 1) + "\n");
								}
							}
						}
					}
				}
				
				// Store any channel volume message reports that were generated for this track and channel
				if (channel_volume_count > 0)
					report.append(temp_channel_volume_report);
			}
		}
				
		// Return the report
		return report.toString();
	}
	
	
	/**
	 * Return a formatted report listing all notes that occur in the piece, either segregated by MIDI track
	 * and MIDI channel, or listed in the temporal order that they occur (regardless of MIDI track or MIDI
	 * channel). Each such note corresponds to a MIDI Note On and MIDI Note Off pair. Also includes all MIDI
	 * pitch bend messages, if this option is selected.
	 * 
	 * @param	temporal_order		Set to true if the notes are to be listed in temporal order. Set to false 
	 *								if they are to be segregated by MIDI track and MIDI channel.
	 * @param	include_pitch_bends	Whether or not to also report MIDI pitch bend messages, mixed in with the
	 *								reports of MIDI notes. IMPORTANT: pitch bend messages are only reported
	 *								if the temporal_order parameter is false; if it is true, no reports are
	 *								generated.
	 * @return						A formatted report of all MIDI Note On / Note Off pairs (and, if selected,
	 *								MIDI pitch bend messages). Includes the (quarter note) beat and MIDI tick 
	 *								for each such note's start and stop. Both beats and	ticks are incremented
	 *								by one in order to report as if the music starts on beat 1 and tick 1,
	 *								rather than beat 0 and tick 0. Also includes the pitch, velocity, track
	 *								and channel for each note.
	 * @throws Exception			An informative exception is thrown if the temporal_order and 
	 *								include_pitch_bends parameters are both set to true.
	 */
	public String prepareNoteReport(boolean temporal_order, boolean include_pitch_bends)
		throws Exception
	{
		if (temporal_order && include_pitch_bends)
			throw new Exception("Cannot report pitch bend messagess if report parameters are not set to segregate notes by track and channel.");
		
		// The report to generate
		StringBuilder report = new StringBuilder();
		
		// Report MIDI Note Ons segregated by MIDI track and MIDI channel
		if (!temporal_order)
		{
			// Go through the MIDI tracks one by one
			for (int tr = 0; tr < tracks.length; tr++)
			{	
				// This MIDI track
				Track track = tracks[tr];

				// Go through active MIDI channels in this MIDI track one by one
				for (int ch = 0; ch < active_channels_per_track[tr].length; ch ++)
				{
					// Only add to the report if there is at least one message on this channel in this track
					if (active_channels_per_track[tr][ch])
					{
						// Note that a new MIDI track and a new MIDI channel is starting
						report.append("\nNOTE ON/OFF MESSAGES ON TRACK " + (tr + 1) + " AND CHANNEL " + 
							(ch + 1) + ":\n");

						// The number of notes encountered on this track and channel
						long note_count = 0;

						// The number of pitch bend messages encountered on this track and channel
						long pitch_bend_count = 0;
						
						// Go through each MIDI event in this track
						for (int ev = 0; ev < track.size(); ev++)
						{
							// This MIDI event
							MidiEvent event = track.get(ev);

							// The MIDI message associated with this MIDI event
							MidiMessage message = event.getMessage();

							// The tick that this event is starting on
							long start_tick = event.getTick();

							// If this is a ShortMessage (which Note Ons are)
							if (message instanceof ShortMessage)
							{
								// This ShortMessage
								ShortMessage short_message = (ShortMessage) message;

								// This MIDI channel
								int channel = short_message.getChannel();

								// Only add to the report if there is at least one message on this channel in
								// this track
								if (channel == ch)
								{
									// If this ShortMessage is a MIDI Note On
									if (short_message.getCommand() == 0x90) // note on
									{
										if (short_message.getData2() != 0) // not velocity 0
										{
											// The pitch of this MIDI Note On
											int pitch = short_message.getData1();

											// The velocity of this MIDI Note On
											int velocity = short_message.getData2();

											// The MIDI tick of the MIDI Note Off associated with this MIDI 
											// Note On
											long end_tick = getTickOfNoteOff(track, ev, channel, pitch);

											// Increment the note count
											note_count++;
											
											// Report timing information about this MIDI Note On and its
											// associated Note Off
											report.append("\tNOTE " + note_count + ": Beat " + 
												getBeatNumber(start_tick) + " to " + getBeatNumber(end_tick) +
												", Tick " + (start_tick + 1) + " to " + (end_tick + 1) + "\n");

											// Report non-timing information about this MIDI Note On
											report.append("\t\tPitch: " + pitch + ", Velocity: " + velocity +
												", Track " + (tr + 1) + ", Channel " + (channel + 1) + "\n");
										}
									}
									
									// If this ShortMessage is a MIDI Pitch Bend message, and if chosen
									else if ( include_pitch_bends && short_message.getCommand() == 0xe0)
									{
										// The (second byte) value of the pitch bend (the less significant
										// first byte is ignored)
										int pitch_bend_value = short_message.getData2();
										
										// Increment the pitch bend count
										pitch_bend_count++;
										
										// Report the pitch bend
										report.append("\tPITCH BEND " + pitch_bend_count + ": " + 
											pitch_bend_value + " (second byte only), Beat: " + 
											getBeatNumber(start_tick) + ", Tick " + (start_tick + 1) + 
											", Track " + (tr + 1) + ", Channel " + (channel + 1) + "\n");
									}
								}
							}
						}
					}
				}
			}
		}
		
		// Report MIDI Note Ons in the order they occur (not segregated by MIDI track or MIDI channel)
		else
		{
			// Provide a header for the report
			report.append("\nNOTE ON/OFF MESSAGES LISTED IN TEMPORAL ORDER:\n");

			// Prepare a temporally sorted list of all notes
			CollectedNoteInfo collected_note_info = new CollectedNoteInfo(tracks);
			List<NoteInfo> temporally_sorted_notes = collected_note_info.noteListToSortedNoteList(collected_note_info.getNoteList());
			
			// Report all MIDI Note Ons and Note Offs
			long note_count = 0;
			for (NoteInfo note : temporally_sorted_notes)
			{
				// Increment the number of notes found
				note_count++;

				// Report timing information about this MIDI Note On and its associated Note Off
				report.append("\tNOTE " + note_count + ": Beat " +  getBeatNumber(note.getStartTick()) + 
					" to " + getBeatNumber(note.getEndTick()) + ", Tick " + note.getStartTick() + " to " +
					note.getEndTick() + "\n");	
				
				// Report non-timing information about this MIDI Note On
				report.append("\t\tPitch: " + note.getPitch() + ", Velocity: " + note.getVelocity() + 
					", Track " + (note.getTrack() + 1) + ", Channel " + (note.getChannel() + 1) + "\n");
			}
		}
				
		// Return the report
		return report.toString();	
	}
	

	/* PRIVATE METHODS **************************************************************************************/


	/**
	 * Returns a formatted string indicating the beat number (assuming quarter note beats) corresponding to
	 * the given MIDI tick. Formats the beat to three decimal places. IMPORTANT: The beat number is
	 * incremented by one, such that the piece in effect starts on beat 1, rather than beat 0.
	 	 * 
	 * @param	tick	The MIDI tick to find the beat for.
	 * @return			The beat number, after being incremented by 1.
	 */
	private String getBeatNumber(long tick)
	{
		DecimalFormat formatter = new java.text.DecimalFormat("#.###");
		double beat = (double) tick / (double) ppqn_ticks_per_beat;
		beat += 1.0;
		return formatter.format(beat);
	}


	/* PRIVATE STATIC METHODS *******************************************************************************/


	/**
	 * Given information for a MIDI Note On event, find the corresponding Note Off event and return the MIDI
	 * tick that the Note Off occurs on.
	 *
	 * @param midi_track			The track the Note On occurred on.
	 * @param note_on_event_index	The event index of the Note On event.
	 * @param note_on_channel		The MIDI channel the Note On occurred on.
	 * @param note_on_pitch			The MIDI pitch of the Note On.
	 * @return						The MIDI tick the Note Off occurs on. If the Note Off never occurs, then 
	 *								the last tick is returned.
	 */
	private static long getTickOfNoteOff( Track midi_track,
	                                      int note_on_event_index,
	                                      int note_on_channel,
	                                      int note_on_pitch )
	{
		for (int ev = note_on_event_index; ev < midi_track.size(); ev++)
		{
			MidiEvent event = midi_track.get(ev);
			MidiMessage message = event.getMessage();
			if (message instanceof ShortMessage)
			{
				// Is this a Note Off message (or equivalent Note On with velocity 0)?
				ShortMessage short_message = (ShortMessage) message;
				if (     short_message.getCommand() == 0x80
				     || (short_message.getCommand() == 0x90 && short_message.getData2() == 0))
				{
					// Is this Note Off message on the same channel, and does it have the same pitch as the
					// Note On message under consideration?
					if ( short_message.getChannel() == note_on_channel && 
					     short_message.getData1() == note_on_pitch)
					{
						return event.getTick();
					}
				}
			}
		}

		// Default to the total number of ticks if the Note Off is not found
		return midi_track.ticks();
	}


	/**
	 * Look ahead on a MIDI track to find the tick corresponding to the MIDI Note Off (or velocity 0 note on)
	 * for the specified NIDI Note On.
	 *
	 * @param note_on				The note on message for which the note off is being searched for.
	 * @param note_on_start_tick	The MIDI tick on which note_on occurred.
	 * @param track					The MIDI track on which note_on is found.
	 * @return						The tick of the note off corresponding to note_on. If the note off never 
	 *								occurs, then the last tick is returned.
	 */
	private static int getTickOfNoteOff( ShortMessage note_on,
	                                     int note_on_start_tick,
	                                     Track track )
	{
		for (int i = note_on_start_tick + 1; i < track.size(); i++)
		{
			MidiEvent end_event = track.get(i);
			MidiMessage end_message = end_event.getMessage();
			if (end_message instanceof ShortMessage)
			{
				ShortMessage end_short_message = (ShortMessage) end_message;
				if (end_short_message.getChannel() == note_on.getChannel()) // must be on same channel
				{
					if (end_short_message.getCommand() == 0x80) // note off
					{
						if (end_short_message.getData1() == note_on.getData1()) // same pitch
							return (int) end_event.getTick();
					}
					if (end_short_message.getCommand() == 0x90) // note on (with vel 0 is equiv to note off)
					{
						if (end_short_message.getData2() == 0) // velocity 0
							if (end_short_message.getData1() == note_on.getData1()) // same pitch
								return (int) end_event.getTick();
					}
				}
			}
		}
		
		// Default to the total number of ticks if the note off is not found
		return (int) track.ticks();
	}
	
	
	/**
	 * For the given MIDI sequence, return an array holding the offset in duration of each note from the exact
	 * idealized duration of its nearest rhythmic value, expressed as a fraction of the duration of an
	 * idealized quarter note. This is an absolute value, so offsets that are longer or shorter than each
	 * idealized duration are identical (they are both expressed here as positive numbers). For example, a
	 * value of 0.1 for a note that happens to be a whole note would indicate that the associated note has a
	 * duration that is one tenth the duration of a quarter note shorter or longer than the idealized duration
	 * of a whole note. The order of the durations in this array is completely unrelated to the order in which
	 * the corresponding notes each occur. Both pitched and unpitched notes are included. This is calculated
	 * without regard to the dynamics, voice or instrument of any given note.
	 *
	 * @param	sequence	The MIDI sequence to parse.
	 * @return				The rhythmic offsets, with one value for each MIDI Note On / Note Off pair.
	 */
	private static double[] getRhytmicValueOffsets(Sequence sequence)
	{
		Track[] tracks = sequence.getTracks();
		
		// The number of ticks per quarter note for the entire sequence
		int ppqn_ticks_per_beat = sequence.getResolution();
		
		// The number of ticks corresponding to each note value
		int ticks_per_thirty_second_note = ppqn_ticks_per_beat / 8;
		int ticks_per_sixteenth_note = ppqn_ticks_per_beat / 4;
		int ticks_per_eighth_note = ppqn_ticks_per_beat / 2;
		int ticks_per_dotted_eighth_note = ppqn_ticks_per_beat * 3 / 4;
		int ticks_per_quarter_note = ppqn_ticks_per_beat;
		int ticks_per_dotted_quarter_note = ppqn_ticks_per_beat * 3 / 2;
		int ticks_per_half_note = ppqn_ticks_per_beat * 2;
		int ticks_per_dotted_half_note = ppqn_ticks_per_beat * 3;
		int ticks_per_whole_note = ppqn_ticks_per_beat * 4;
		int ticks_per_dotted_whole_note = ppqn_ticks_per_beat * 6;
		int ticks_per_double_whole_note = ppqn_ticks_per_beat * 8;
		int ticks_per_dotted_double_whole_note = ppqn_ticks_per_beat * 12;
		
		// The number of ticks corresponding to each note value in the form of an array
		int central_ticks_per_note_value[] = new int[] { ticks_per_thirty_second_note, // i=0
														 ticks_per_sixteenth_note, // i=1
														 ticks_per_eighth_note, // i=2
														 ticks_per_dotted_eighth_note, // i=3
														 ticks_per_quarter_note, // i=4
														 ticks_per_dotted_quarter_note, // i=5
														 ticks_per_half_note, // i=6
														 ticks_per_dotted_half_note, // i=7
														 ticks_per_whole_note, // i=8
														 ticks_per_dotted_whole_note, // i=9
														 ticks_per_double_whole_note, // i=10
														 ticks_per_dotted_double_whole_note }; // i=11
		
		// The lowest number of ticks that a note of the given value can have
		int lower_bound_ticks_per_note_value[] = new int[central_ticks_per_note_value.length];
		lower_bound_ticks_per_note_value[0] = 0;
		for (int i = 1; i < lower_bound_ticks_per_note_value.length; i++)
			lower_bound_ticks_per_note_value[i] = central_ticks_per_note_value[i-1] + ((central_ticks_per_note_value[i] - central_ticks_per_note_value[i-1]) / 2);
		
		// The offset in duration of each note from the exact idealized duration of its nearest rhythmic
		// value, expressed as a fraction of the duration of an idealized quarter note
		LinkedList<Double> quantization_offsets_in_quarter_note_fractions = new LinkedList<>();
		
		// Fill rhythmic_duration_note_counts for the entire sequence
		for (int tr = 0; tr < tracks.length; tr++)
		{
			// Process this track
			Track track = tracks[tr];
			for (int ev = 0; ev < track.size(); ev++)
			{
				// Get the MIDI message corresponding to the next MIDI event
				MidiEvent event = track.get(ev);
				MidiMessage message = event.getMessage();

				// If message is a ShortMessage (which Note Ons are)
				if (message instanceof ShortMessage)
				{
					ShortMessage short_message = (ShortMessage) message;

					// If a Note On message is encountered
					if (short_message.getCommand() == 0x90)
					{
						if (short_message.getData2() != 0) // not velocity 0
						{
							// Look ahead to find the corresponding note off for this note on. Defaults
							// to the last tick if no corresponding note off is found.
							int event_start_tick = (int) event.getTick();
							int event_end_tick = getTickOfNoteOff(short_message, ev, track);
							
							// Calculate duration in ticks of the note
							int duration_in_ticks = event_end_tick - event_start_tick;
							
							// Map each note to its appropriate rhythmic value
							for (int i = 0; i < central_ticks_per_note_value.length; i++)
							{
								if (i == central_ticks_per_note_value.length - 1)
								{
									// Fill in quantization_offsets_in_quarter_note_fractions
									double quantization_offset_in_ticks = (double) Math.abs(duration_in_ticks - central_ticks_per_note_value[i]);
									double quantization_offset_in_quarter_note_fractions = quantization_offset_in_ticks / (double) central_ticks_per_note_value[4];
									quantization_offsets_in_quarter_note_fractions.add(quantization_offset_in_quarter_note_fractions);
								}
								else if (duration_in_ticks < lower_bound_ticks_per_note_value[i+1])
								{
									// Fill in quantization_offsets_in_quarter_note_fractions
									double quantization_offset_in_ticks = (double) Math.abs(duration_in_ticks - central_ticks_per_note_value[i]);
									double quantization_offset_in_quarter_note_fractions = quantization_offset_in_ticks / (double) central_ticks_per_note_value[4];
									quantization_offsets_in_quarter_note_fractions.add(quantization_offset_in_quarter_note_fractions);
									
									// Exit the loop
									break;
								}
							}
						}
					}
				}
			}
		}			
		
		// Prepare and return rhythmic_value_offsets
		double[] rhythmic_value_offsets = new double[quantization_offsets_in_quarter_note_fractions.size()];
		for (int i = 0; i < rhythmic_value_offsets.length; i++)
			rhythmic_value_offsets[i] = quantization_offsets_in_quarter_note_fractions.get(i);
		return rhythmic_value_offsets;
	}
	
	
	/**
	 * Returns a formatted report indicating whether or not the values for the quantity referred to by
	 * inconsistency_type_identifier for some single file are consistent (i.e. the quantity has only a single
	 * value in the entire file) or whether the values vary (i.e. has multiple values for the file). If
	 * report_values is true, the particular value or values to_check contains are included in this report. A
	 * separate report is also added to inconsistencies_found, but only if to_check turns out to be internally
	 * inconsistent.
	 * 
	 * @param to_check						A set of values that a single file has for the quantity specified
	 *										in inconsistency_type_identifier. This array also serves as the
	 *										array to check for inconsistencies (i.e. multiple values). It
	 *										is assumed that each of its values are unique (i.e. there are no
	 *										two entries with the same value). May be null, in which case this
	 *										methods treats it as if there are no inconsistencies.
	 * @param report_values					Whether to report, in the case of multiple values in to_check,
	 *										specifically what these values are. If this is false, a 
	 *										consistency result is still returned, but without details.
	 * @param inconsistency_type_identifier	The identifying name of the type of inconsistency being checked
	 *										for (e.g. Tempo). This is just used in the report generated, not
	 *										for any other internal processing.
	 * @param inconsistencies_found			A list of inconsistencies that have already been found. Reports
	 *										of new inconsistencies found are added to it (including the
	 *										particular values present, if report_values is true).
	 * @return								A formatted report indicating whether to_check is Consistent
	 *										(has 0 or 1 values) or Varies (has more than 1 value). In the
	 *										latter case, also includes the particular values that are present
	 *										if report_values is set to true.
	 */
	private static String getIntraConsistencyReport( String[] to_check,
	                                                 boolean report_values,
	                                                 String inconsistency_type_identifier,
	                                                 LinkedList<String> inconsistencies_found )
	{
		// The report to return
		String return_string;
		
		// The report to add to inconsistencies_found
		String inconsistencies_found_note = null;
		
		// Find if to_check contains more than one value
		if (to_check == null)
			return_string = "Consistent";
		else if (to_check.length == 1)
			return_string=  "Consistent";
		else
		{
			return_string = "Varies";
			inconsistencies_found_note = inconsistency_type_identifier;
		}

		// Report the actual values
		if (report_values)
		{
			String values = "";
			if (to_check == null || (to_check.length == 1 && to_check[0] == null) )
				values += "Not present in file";
			else for (int i = 0; i < to_check.length; i++)
			{
				values += to_check[i];
				if (i != (to_check.length - 1)) values += " + ";
			}
			
			return_string += " (" + values + ")";
			
			if (inconsistencies_found_note != null)
				inconsistencies_found_note += " (" + values + ")";
		}
		
		// Add a separate report to inconsistencies_found, if an inconsistency has been found
		if (inconsistencies_found_note != null)
			inconsistencies_found.add(inconsistencies_found_note);
		
		// Return the primary report
		return return_string;
	}
	
	
	/**
	 * Returns a formatted report indicating whether or not the values for some quantity (e.g. tempo) are
	 * consistent across all the files referred to by unique_values_per_file. The quantity is marked
	 * Consistent if the exact same values occur in all files. The quantity is marked Varies if one or more
	 * files has different values than another. Multiplicity and order are ignored (so tempos of 120 and then
	 * 80 BPM in one file, and 120, 80 and then 120 BPM in another would be considered Consistent, but another
	 * file with a tempo of just 80 BPM, or of 90 and then 120 BPM would result in a report of Varies). If
	 * report_values is true, the particular value sets found are reported, as are the paths of the specific
	 * files associated with each values set.
	 * 
	 * @param unique_values_per_file	An array where the first index specifies a file and the second index
	 *									corresponds to each unique value that a file can have for the quantity
	 *									under consideration. The values for each file are assumed to be unique
	 *									(i.e. there are no multiple identical values for the same file). The
	 *									values for a given file may be null, in which case this method marks 
	 *									it as unspecified (which itself then acts as a unique value set).
	 * @param files_to_check			The files from which the entries of unique_values_per_file were found.
	 *									The index of files_to_check must match the ordering of the first index
	 *									of unique_values_per_file. files_to_check is used simply to note the
	 *									file names corresponding to each value set.
	 * @param report_values				Whether or not to report all the unique value sets found. If this is 
	 *									false, a consistency result is still returned, but without details.
	 * @return							A formatted report indicating whether unique_values_per_file is
	 *									Consistent (i.e. all files have the same value sets) or Varies
	 *									(files have more than one value set). The particular values are 
	 *									reported if report_values is set to true.
	 */
	private static String getInterConsistencyReport( String[][] unique_values_per_file,
	                                                 File[] files_to_check,
	                                                 boolean report_values )
	{
		// A list to which unique value sets are added to as the files in unique_values_per_file are 
		// traversed one by one. Will hold all the unique (i.e. no doubles) value sets found in all files in
		// unique_values_per_file by the end of processing.
		LinkedList<String[]> unique_value_sets_found_so_far_all_files = new LinkedList<>();

		// A list of the file paths from files_to_check corresponding to each value set entry in 
		// unique_value_sets_found_so_far_all_files (the entries of the two lists correspond to each other)
		LinkedList<LinkedList<String>> file_paths_for_each_value_set_found_so_far = new LinkedList<>();
		
		// Populate unique_value_sets_found_so_far_all_files by going through each file, one by one
		for (int file = 0; file < unique_values_per_file.length; file++)
		{
			// Note the path of this file
			String this_file_path = files_to_check[file].getAbsolutePath();

			// Deal with case where a given file may have no values
			String[] unique_values_this_file;
			if ( unique_values_per_file[file] == null ||
			     ( unique_values_per_file[file].length == 1 && unique_values_per_file[file][0] == null ) )
			{
				unique_values_this_file = new String[1];
				unique_values_this_file[0] = "Not present in file";
			}
			else
				unique_values_this_file = unique_values_per_file[file];

			// Add the value set from this file to unique_value_sets_found_so_far_all_files if it is not 
			// already there.
			if (unique_value_sets_found_so_far_all_files.isEmpty())
			{
				unique_value_sets_found_so_far_all_files.add(unique_values_this_file);
				
				LinkedList<String> new_file_list_for_this_value_set = new LinkedList<>();
				new_file_list_for_this_value_set.add(this_file_path);
				file_paths_for_each_value_set_found_so_far.add(new_file_list_for_this_value_set);
			}
			else
			{
				boolean match_found = false;
				for (int set = 0; set < unique_value_sets_found_so_far_all_files.size(); set++)
				{
					if (StringMethods.doStringArraysMatch(unique_values_this_file, unique_value_sets_found_so_far_all_files.get(set)))
					{
						match_found = true;
						
						LinkedList<String> new_file_list_for_this_value_set = file_paths_for_each_value_set_found_so_far.get(set);
						new_file_list_for_this_value_set.add(this_file_path);
						
						break;
					}
				}
				
				if (!match_found)
				{
					unique_value_sets_found_so_far_all_files.add(unique_values_this_file);
					
					LinkedList<String> new_file_list_for_this_value_set = new LinkedList<>();
					new_file_list_for_this_value_set.add(this_file_path);
					file_paths_for_each_value_set_found_so_far.add(new_file_list_for_this_value_set);
				}
			}
		}
		
		// The report to return
		StringBuilder report = new StringBuilder();
		
		// Prepare the basic report
		if (unique_value_sets_found_so_far_all_files.size() == 1)
			report.append("Consistent (the same value set found in all " + unique_values_per_file.length + " files}");
		else 
			report.append("Varies (" + unique_value_sets_found_so_far_all_files.size() + " distinct value sets found across the " + unique_values_per_file.length + " files)");
		
		// Specify all the unique value sets
		if (report_values)
		{
			for (int set = 0; set < unique_value_sets_found_so_far_all_files.size(); set++)
			{
				// Note the value set
				report.append("\n\t\t< ");
				for (int val = 0; val < unique_value_sets_found_so_far_all_files.get(set).length; val++)
				{
					report.append(unique_value_sets_found_so_far_all_files.get(set)[val]);
					if (val != (unique_value_sets_found_so_far_all_files.get(set).length - 1))
						report.append(", ");
				}
				report.append(" >: " + file_paths_for_each_value_set_found_so_far.get(set).size() + " files");
				
				// Note the file paths that have this value set
				for (int file = 0; file < file_paths_for_each_value_set_found_so_far.get(set).size(); file++)
					report.append("\n\t\t\t" + file_paths_for_each_value_set_found_so_far.get(set).get(file));
			}
		}

		// Return the report
		return report.toString();
	}
}