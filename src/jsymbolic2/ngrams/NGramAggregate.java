package jsymbolic2.ngrams;

import java.util.HashMap;
import java.util.LinkedList;

/**
 * This object aggregates n-grams generated by the NGramGenerator object and returns useful information for 
 * use by feature calculators. Each instance of this object is instantiated with a list of n-grams which all
 * have the same n-value and encode the same kind of musical moment. It creates a hash map mapping a unique 
 * identifier to the normalized frequency at which n-grams with that identifier occur. It also creates two 
 * arrays: one containing each n-gram that has a unique identifier, and the other containing the normalized 
 * frequency at which the n-gram at the same index occurs.
 * 
 * @author radamian
 */
public class NGramAggregate 
{
	/**
	 * The list of n-grams aggregated by this object. Each n-gram listed has the same n-value and encodes the
	 * same kind of musical moment (vertical interval, melodic interval, rhythmic value, etc.).
	 */
	protected LinkedList<NGram> n_grams;
	
	/**
	 * A HashMap linking an n-gram having a unique identifier with its normalized frequency.
	 */
	protected HashMap<NGram, Double> n_gram_by_unique_id_to_frequency_map;
	
	/**
	 * An array of n-grams having a unique identifier. Each entry corresponds to the entry at the same index 
	 * in frequencies_by_unique_id, the normalized frequency of that unique n-gram. Each entry is also a key
	 * in the n_gram_by_unique_id_to_frequency_map field.
	 */
	protected NGram[] n_grams_by_unique_id;
	
	/**
	 * A normalized histogram containing the frequencies of each n-gram having a unique identifier. Each entry 
	 * corresponds to the entry at the same index in n_grams_by_unique_id, the n-gram occurring with that
	 * frequency.
	 */
	protected double[] frequencies_by_unique_id;
	
	
	/* CONSTRUCTOR ******************************************************************************************/
	
	
	/**
	 * Create an aggregate of the given list of n-grams.
	 * 
	 * @param	n_gram_list		The list of n-grams that this object aggregates.
	 */
	public NGramAggregate(LinkedList<NGram> n_gram_list)
	{
		n_grams = n_gram_list;
		n_gram_by_unique_id_to_frequency_map = new HashMap<>();
		
		LinkedList<NGram> unique_n_grams_ll = new LinkedList<>();
		
		// Iterate through the n-grams passed to the constructor, creating a set of n-grams having unique
		// identifiers
		for (NGram n_gram: n_grams)
		{
			boolean equivalent_id_found = false;
			
			// Verify whether an n-gram with the same identifier has been encountered
			for (NGram key: n_gram_by_unique_id_to_frequency_map.keySet())
			{
				equivalent_id_found = equivalentIdentifiers(n_gram.getIdentifier(), key.getIdentifier());
				
				if (equivalent_id_found)
				{
					double frequency = n_gram_by_unique_id_to_frequency_map.get(key);
					n_gram_by_unique_id_to_frequency_map.remove(key);
					n_gram_by_unique_id_to_frequency_map.put(key, frequency + 1);
					break;
				}
			}
			
			if (!equivalent_id_found) 
			{
				n_gram_by_unique_id_to_frequency_map.put(n_gram, 1.0);
				unique_n_grams_ll.add(n_gram);
			}
		}
		
		n_grams_by_unique_id = new NGram[unique_n_grams_ll.size()];
		for (int n_gram = 0; n_gram < n_grams_by_unique_id.length; n_gram++)
			n_grams_by_unique_id[n_gram] = unique_n_grams_ll.get(n_gram);
		
		// Prepare array for normalization
		double[] frequencies_to_normalize = new double[n_grams_by_unique_id.length];
		for (int i = 0; i < frequencies_to_normalize.length; i++)
			frequencies_to_normalize[i] = n_gram_by_unique_id_to_frequency_map.get(n_grams_by_unique_id[i]);
		
		frequencies_by_unique_id = mckay.utilities.staticlibraries.MathAndStatsMethods.normalize(frequencies_to_normalize);
		
		// Update the values returned by n_gram_by_unique_id_to_frequency_map to the normalized frequencies
		for (int i = 0; i < n_grams_by_unique_id.length; i++)
		{
			NGram n_gram = n_grams_by_unique_id[i];
			n_gram_by_unique_id_to_frequency_map.remove(n_gram);
			n_gram_by_unique_id_to_frequency_map.put(n_gram, frequencies_by_unique_id[i]);
		}
		
		/*
		System.out.println("\n\nN-grams and their frequencies: ");
		for (int i = 0; i < identifiers.length; i++)
		{
			System.out.println("\n" + identifiers[i].nGramToString());
			System.out.println(frequencies[i]);
		}
		
		double[][] most_common_id = getMostCommonIdentifier();
		System.out.println("\n\n Most Common ID: ");
		for (int i = 0; i < most_common_id.length; i++)
			for (int voice = 0; voice < most_common_id[i].length; voice++)
				System.out.print(most_common_id[i][voice] + " ");
		*/
	}
	
	
	/* PRIVATE METHODS **************************************************************************************/
	
	
	/* PUBLIC METHODS ***************************************************************************************/
		
	
	/**
	 * @return	The map between this object's n-gram's identifiers and their normalized frequencies.
	 */
	public HashMap<NGram, Double> getNGramByUniqueIdToFrequencyMap()
	{
		return n_gram_by_unique_id_to_frequency_map;
	}

	
	/**
	 * @return	The array of normalized frequencies corresponding to each unique n-gram identifier.
	 */
	public double[] getFrequenciesByUniqueId()
	{
		return frequencies_by_unique_id;
	}
	
	
	/**
	 * Returns a boolean indicating whether two given identifiers are the same.
	 * 
	 * @param	id1			The first identifier.
	 * @param	id2			The second identifier.
	 * @return				Whether the two identifiers are the same.
	 */
	public boolean equivalentIdentifiers(	LinkedList<Double>[] id1, 
											LinkedList<Double>[] id2)
	{
		boolean equivalent_id = false;
		
		for (int i = 0; i < id2.length; i++)
		{
			if (id1[i].size() != id2[i].size())
			{
				equivalent_id = false;
				break;
			}

			for (int j = 0; j < id2[i].size(); j++)
				if (id1[i].get(j).doubleValue() != id2[i].get(j).doubleValue())
					equivalent_id = false;
		}
		
		return equivalent_id;
	}
	
	
	/**
	 * Returns the normalized frequency of the n-gram having the given unique identifier. If there is no
	 * n-gram with the given identifier, then a value of -1.0 is returned.
	 * 
	 * @param	id			The identifier of the n-gram.
	 * @return				The frequency of the n-gram with the given identifier.
	 */
	public double getFrequencyOfIdentifier(LinkedList<Double>[] id)
	{
		double frequency = -1.0;
		
		for (NGram n_gram: n_gram_by_unique_id_to_frequency_map.keySet())
			if (equivalentIdentifiers(n_gram.getIdentifier(), id))
				return n_gram_by_unique_id_to_frequency_map.get(n_gram);
		
		return frequency;
	}
	
	
	/**
	 * Return the most common identifier in this object's list of n-grams.
	 * 
	 * @return	The identifier of the n-gram that occurs the most frequently.
	 */
	public LinkedList<Double>[] getMostCommonIdentifier()
	{
		int index_of_highest_frequency = mckay.utilities.staticlibraries.MathAndStatsMethods.getIndexOfLargest(frequencies_by_unique_id);
		LinkedList<Double>[] most_common_identifier = n_grams_by_unique_id[index_of_highest_frequency].getIdentifier();
		
		return most_common_identifier;
	}
	
	
	/**
	 * Return the second most common identifier in this object's list of n-grams.
	 * 
	 * @return	The identifier of the n-gram that occurs the second most frequently.
	 */
	public LinkedList<Double>[] getSecondMostCommonIdentifier()
	{
		int index_of_second_highest_frequency = mckay.utilities.staticlibraries.MathAndStatsMethods.getIndexOfSecondLargest(frequencies_by_unique_id);
		LinkedList<Double>[] second_most_common_identifier = n_grams_by_unique_id[index_of_second_highest_frequency].getIdentifier();
		
		return second_most_common_identifier;
	}
}
